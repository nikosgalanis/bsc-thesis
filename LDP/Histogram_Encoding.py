import numpy as np
import random
import math
import numbers

class Histogram_Encoding_client():
	def __init__(self, e, d):
		# initialization of the protocol's constants
		self.e = e
		self.d = d

	# encoding consists of creating a d-bit vetor, where
	# only the v-th element is 1, and every other equal to 0
	def encode(self, v):
		assert(v < self.d)
		B = np.zeros(self.d)
		B[v] = 1
		return B
	
	# perturbation consists of adding noise generated
	# from the laplace distribution to each element
	def perturb(self, ret):
		B = ret
		for i in range(len(B)):
			B[i] += np.random.laplace(scale = (2/self.e))
		
		return B
	
	# randomization consists of perturbing the encoded value
	def randomize(self, v):
		return self.perturb(self.encode(v))

class Histogram_Encoding_aggregator():
	def __init__(self, e, d):
		# initialization of the protocol's constants
		self.e = e
		self.d = d
			
	def aggregate(self, config):

		# define the needed variables from the configuration dict provided
		reported_values = config['reported_values']
		e = self.e
		d = self.d
		
		threshold = config['threshold']
		method = config['method']

		# array to store the results
		results = np.zeros(d)
		# Summation with Histogram Encoding method
		if method == 'SHE':
			for i in range(d):
				sum_v = 0
				# just sum all the 1s from the v-th elements of the results
				for j in reported_values:
					sum_v += j[i]
			
				results[i] = sum_v

			return results
		else:
			# Thresholding with Histogram Encoding method

			# count of the reported values
			n = len(reported_values)

			# p and q according to the theory
			p = 1 - (1/2) * math.exp((e/2) * (threshold - 1))
			q = (1/2) * math.exp(-(e/2) * threshold)

			for i in range(d):
				sum_v = 0
				# Support(B) = {v | B[v] > threshold}
				# thus, each reported value grater than the threshold is supported
				for j in reported_values:
					if j[i] > threshold:
						sum_v += 1

				# normalize the sum by trying to extract the noise
				results[i] = ((sum_v) - n * q) / (p - q)
				# if a negative sum is generated by the normalization, convert it to zero
				if (results[i] < 0):
					results[i] = 0
			
			return results

