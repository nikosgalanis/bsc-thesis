import numpy as np
import random
import math
import numbers

class Direct_Encoding_client():
	def __init__(self, e, d):
		# initialization of the protocol's constants
		self.e = e
		self.d = d
		# p and q are fixed, depending on the domain size and the epsilon value
		self.p = math.exp(self.e) / (math.exp(self.e) + self.d - 1)
		self.q = 1 / (math.exp(self.e) + self.d - 1)

	# encoding: simply return the value itself
	def encode(self, v):
		return v

	def perturbe(self, ret):
		x = ret
		# generate a random number in the range (0,1)
		res = random.random()
		
		# if it is less than p, report the real value
		if (res < self.p):
			pert = x
		else:
			# else chose one of the other values of the domain
			false_xs = [i for i in range(self.d) if i != x]		

			pert = random.choice(false_xs)
		
		return pert

	# randomization consists of perturbing the encoded value
	def randomize(self, v):
		return self.perturbe(self.encode(v))


class Direct_Encoding_aggregator():
	def __init__(self, e, d):
		# initialization of the protocol's constants
		self.e = e
		self.d = d
		# p and q are fixed, depending on the domain size and the epsilon value
		self.p = math.exp(self.e) / (math.exp(self.e) + self.d - 1)
		self.q = 1 / (math.exp(self.e) + self.d - 1)

	def aggregate(self, config):
    		# define the needed variables from the configuration dict provided
		reported_values = config['reported_values']
		e = config['epsilon']
		d = config['d']

		# array to store the results
		results = np.zeros(d)
		n = len(reported_values)
		
		# compute p and q based on the espilon value and the domain size
		p = math.exp(e) / (math.exp(e) + d - 1)
		q = 1 / (math.exp(e) + d - 1)

		# compute the estimation for each value of the domain
		for i in range(d):
			sum_v = 0
			for j in reported_values:
    			# Support(i) = {i}, thus the protocol supports only the values equal to 
				# the current value
				if j == i:
					sum_v += 1
			# normalize the sum by trying to extract the noise
			results[i] = ((sum_v) - n * q) / (p - q)
			# if a negative sum is generated by the normalization, convert it to zero
			if (results[i] < 0):
				results[i] = 0

		return results